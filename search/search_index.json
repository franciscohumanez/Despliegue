{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pr\u00e1ctica 2.1 Instalaci\u00f3n y configuraci\u00f3n de servidor web Nginx","text":""},{"location":"#instalacion-del-servidor","title":"Instalaci\u00f3n del servidor","text":"<p>Antes de instalar, actualizamos los repositorios <code>sudo apt update</code> y despu\u00e9s instalamos el paquete <code>sudo apt install nginx</code>.</p> <p></p> <p>Comprobamos que se ha instaldo y que est\u00e1 funcionando correctamente con el comando <code>systemctl status nginx</code>.</p> <p></p>"},{"location":"#creacion-de-las-carpetas-del-sitio-web","title":"Creaci\u00f3n de las carpetas del sitio web","text":"<p>Creamos la carpeta de nuestro sitio web con el comando <code>sudo mkdir -p /var/www/practica2.1/html</code>.</p> <p></p> <p>Dentro de esta carpeta, clonamos el siguiente repositorio de github:</p> <pre><code>https://github.com/cloudacademy/static-website-example\n</code></pre> <p></p> <p>Hacemos al usuario <code>www-data</code> propietario de esta carpeta, con el comando</p> <pre><code>sudo chown -R www-data:www-data /var/www/nombre_web/html\n</code></pre> <p></p> <p>Desde nuestro equipo cliente accedemos a la ip del servidor <code>http://192.168.1.143</code> desde un navegador y deber\u00eda de salir algo como esto: </p> <p></p>"},{"location":"#configuracion-de-servidor-web-nginx","title":"Configuraci\u00f3n de servidor web NGINX","text":"<p>Creamos un archivo de configuraci\u00f3n que es la p\u00e1gina que se muestra si accedemos al servidor sin indicar ning\u00fan sitio web.</p> <pre><code>sudo nano /etc/nginx/sites-available/practica2.1\n</code></pre> <p>En este archivo de configuraci\u00f3n, hay que poner lo siguiente:</p> <pre><code>server {\n        listen 80;\n        listen [::]:80;\n        root /var/www/practica2.1/html/static-website-example;\n        index index.html index.htm index.nginx-debian.html;\n        server_name nombre_web;\n        location / {\n                try_files $uri $uri/ =404;\n        }\n}\n</code></pre> <p></p> <p>Creamos un archivo simb\u00f3lico entre este archivo y el de sitios que  est\u00e1n habilitados, para que se d\u00e9 de alta autom\u00e1ticamente  con <code>sudo ln -s /etc/nginx/sites-available/practica2.1 /etc/nginx/sites-enabled/</code>.</p> <p></p>"},{"location":"#comprobaciones","title":"Comprobaciones","text":"<p>En nuestra m\u00e1quina anfitriona tenemos que editar el archivo <code>C:\\Windows\\System32\\drivers\\etc\\hosts</code>. Y a\u00f1adir:</p> <pre><code>192.168.1.143 practica2.1\n</code></pre> <p></p>"},{"location":"#ftp","title":"FTP","text":"<p>FTP es un protocolo de transferencia de archivos entre sistemas conectados a una red TCP. Actualmente, es un protocolo que poco a poco va abandon\u00e1ndose, pero ha estado vigente m\u00e1s de 50 a\u00f1os.</p>"},{"location":"#configurar-servidor-sftp-en-debian","title":"Configurar servidor SFTP en debian","text":"<p>Primero actualizamos los repositorios <code>sudo apt-get update</code>, despu\u00e9s instalamos el paquete.</p> <pre><code>sudo apt-get install vsftpd\n</code></pre> <p>Creamos una carpeta en el home de debian</p> <pre><code>mkdir /home/francisco/ftp\n</code></pre> <p></p> <p>Creamos los certificados de seguridad necesarios para aportar la capa de cifrado a nuestra conexi\u00f3n</p> <pre><code>sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/ssl/private/vsftpd.pem -out /etc/ssl/private/vsftpd.pem\n</code></pre> <p></p> <p>Editamos el archivo de configuraci\u00f3n de este servicio <code>sudo nano /etc/vsftpd.conf</code></p> <pre><code>rsa_cert_file=/etc/ssl/private/vsftpd.pem\nrsa_private_key_file=/etc/ssl/private/vsftpd.pem\nssl_enable=YES\nallow_anon_ssl=NO\nforce_local_data_ssl=YES\nforce_local_logins_ssl=YES\nssl_tlsv1=YES\nssl_sslv2=NO\nssl_sslv3=NO\nrequire_ssl_reuse=NO\nssl_ciphers=HIGH\n\nlocal_root=/home/nombre_usuario/ftp\n</code></pre> <p></p> <p>Reiniciamoss el servicio para cojer la nueva configuraci\u00f3n <code>sudo systemctl restart --now vsftpd</code>.</p> <p>Desde el equipo cliente, abrimos el programa filezilla y nos concetamos al servidor Debian. Y subimos un archivo a la carpeta <code>/home/francisco/ftp</code>.</p> <p></p> <p>Desde el Debian ya podemos ver el archivo subido:</p> <p></p>"},{"location":"#https","title":"HTTPS","text":"<p>En este apartado vamos a a\u00f1adir a nuestro servidor una capa de seguridad necesaria. Haremos que todos nuestros sitios web alojados hagan uso de certificados SSL y se acceda a ellos por medio de HTTPS.</p>"},{"location":"#creacion-de-certificado","title":"Creaci\u00f3n de certificado","text":"<p>Primero vamos a crear un directorio para almacenar los certificados <code>sudo mkdir /etc/ssl/certificados</code>.</p> <p>Generamos la clave privada <code>sudo openssl genpkey -algorithm RSA -out /etc/ssl/certificados/clave_privada.key</code>.</p> <p>Y por ultimo generamos un certificado autofirmado <code>sudo openssl req -new -x509 -key /etc/ssl/certificados/clave_privada.key -out /etc/ssl/certificados/certificado_autofirmado.crt -days 365</code>.</p> <p></p>"},{"location":"#configuracion-de-nginx","title":"Configuraci\u00f3n de Nginx","text":"<p>Vamos a configurar el archivo de nginx <code>/etc/nginx/sites-available/default</code>.</p> <p></p> <p>Reiniciamos Nginx <code>sudo systemctl restart nginx</code>.</p>"},{"location":"#resultado","title":"Resultado","text":""},{"location":"practica2/","title":"Pr\u00e1ctica 2.2 Autenticaci\u00f3n en Nginx","text":""},{"location":"practica2/#paquetes-necesarios","title":"Paquetes necesarios","text":"<p>Para esta pr\u00e1ctica podemos utilizar la herramienta openssl para crear las contrase\u00f1as. En primer lugar debemos comporbar si el paquete esta instalado <code>dpkg -l | grep openssl</code>. Y si no, instalarlo.</p>"},{"location":"practica2/#creacion-de-usuarios-y-contrasenas-para-el-acceso-web","title":"Creaci\u00f3n de usuarios y contrase\u00f1as para el acceso web","text":"<p>Creamos un archivo oculto llamado <code>.htpasswd</code> en el directorio de configuraci\u00f3n <code>/etc/nginx</code> donde guardar nuestros usuarios y contrase\u00f1as:</p> <pre><code>sudo sh -c \"echo -n 'vuestro_nombre:' &gt;&gt; /etc/nginx/.htpasswd\"\n</code></pre> <p></p> <p>Creamos una contrase\u00f1a para el usuario:</p> <pre><code>sudo sh -c \"openssl passwd -apr1 &gt;&gt; /etc/nginx/.htpasswd\"\n</code></pre> <p></p>"},{"location":"practica2/#configuracion-del-servidor-nginx-para-usar-autenticacion","title":"Configuraci\u00f3n del servidor Nginx para usar autenticaci\u00f3n","text":"<p>Editamos el archivo <code>/etc/nginx/sites-available/practica2.1</code>. A\u00f1adimos estas dos l\u00edneas al archivo:</p> <pre><code>auth_basic \"Area restringida\";\nauth_basic_user_file /etc/nginx/.htpasswd;\n</code></pre> <p></p> <p>Reiniciamos el servicio para que se apliquen los cambios <code>sudo systemctl restart nginx</code>.</p> <p>Comprobamos desde la m\u00e1quina f\u00edsica que al acceder a <code>http://practica21.com</code> nos pide las credenciales</p> <p></p>"},{"location":"practica2/#tarea-1","title":"Tarea 1","text":"<p>Adjunta una captura de pantalla de los logs donde se vea que intentas entrar primero con un usuario inv\u00e1lido y con otro v\u00e1lido. Indica d\u00f3nde podemos ver los errores de usuario inv\u00e1lido o no encontrado, as\u00ed como donde podemos ver el n\u00famero de error que os aparec\u00eda antes Archivo access.log </p> <p>Archivo error.log </p>"},{"location":"practica2/#configuracion-de-la-autenticacion-basica-con-la-restriccion-de-acceso-por-ip","title":"Configuraci\u00f3n de la autenticaci\u00f3n b\u00e1sica con la restricci\u00f3n de acceso por IP","text":""},{"location":"practica3/","title":"Pr\u00e1ctica 2.3 - Proxy inverso con Nginx","text":""},{"location":"practica3/#que-es-un-servidor-proxy","title":"\u00bfQu\u00e9 es un servidor proxy?","text":"<p>Es un servidor que se encuentra frente a un grupo de m\u00e1quinas cliente. Cuando esas m\u00e1quinas realizan solicitudes a sitios y servicios en Internet, el servidor proxy intercepta esas solicitudes y luego se comunica con los servidores web en nombre de esos clientes, como un intermediario.</p>"},{"location":"practica3/#configuracion","title":"Configuraci\u00f3n","text":"<p>Vamos a configurrar dos debian con sendos servidores Nginx. Para eso la m\u00e1quina que ya tenemos, la clonamos.</p> <p>[!WARNING] Cuidado</p> <p>Ojo al clonar la m\u00e1quinass virtuales porque hay que darle a crear una nueva MAC, de lo contrario no tendr\u00e9is IP en esa m\u00e1quina.</p> <ol> <li>En primer lugar, he cambiado el nombre que ten\u00eda la web por el de <code>webserver</code>, esto implica:</li> <li> <p>Cambiar el nombre del archivo de configuraci\u00f3n de sitios disponibles para Nginx </p> </li> <li> <p>Cambiar el nombre del sitio web dentro de este archivo de configuraci\u00f3n deonde haga falta. </p> </li> <li> <p>Eliminar el link sim\u00f3lico antiguo con el comando <code>unlink practica21</code> dentro de la carpeta <code>sites-enabled</code> y crear uno nuevo para el nuevo nombre de archivo. </p> </li> <li> <p>En el archivo de configuraci\u00f3n del sitio web, en lugar de hacer que el servidor escuche en el puerto 80, lo he cambiado al 8080. </p> </li> <li> <p>Reiniciar Nginx <code>sudo systemctl restart nginx</code></p> </li> </ol>"},{"location":"practica3/#nginx-proxy-inverso","title":"Nginx proxy inverso","text":"<p>Ahora, cuando intentamos acceder a <code>http://practica21.com</code>, en realidad estamos accediendo al proxy, que nos redirigir\u00e1 a http://webserver:8080, el servidor web que acabamos de configurar para que escuche con ese nombre en el puerto 8080. Para ello: - Crear un archivo de configuraci\u00f3n en sites-available con el nombre practica21. - Este archivo de configuraci\u00f3n ser\u00e1 m\u00e1s simple, tendr\u00e1 la siguiente forma </p> <p>[!WARNING] \u00a1Atenci\u00f3n, muy importante!</p> <p>Hay que modificar el archivo host que configuramos en la pr\u00e1ctica 2.1. </p>"},{"location":"practica3/#anadiendo-cabeceras","title":"A\u00f1adiendo cabeceras","text":"<p>Para a\u00f1adir cabeceras, en el archivo de configuraci\u00f3n del setio web debemos a\u00f1adir dentro del bloque <code>location / { ... }</code> debemos a\u00f1adir la directiva:</p> <pre><code>add_header Host Proxy_inverso_Francisco\n</code></pre> <p></p> <p>Reiniciamos Nginx </p>"},{"location":"practica4/","title":"Pr\u00e1ctica 2.4 - Proxys inverso con balanceo de carga","text":"<p>Ya no vamos a utilizar los sitios web que hemos configurado en las pr\u00e1cticas anteriores. Por ello, para evitarnos una serie de problemas que pueden surgir, vamos a desactivarlos.</p> <p>Dentro de la carpeta /etc/nginx/sites-enabled debemos ejecutar unlink nombre_archivo para cada uno de los archivos de los sitios web que tenemos. </p>"},{"location":"practica4/#nginx-servidor-web-1","title":"Nginx servidor web 1","text":"<p>Debemos configurar este servidor web para que sirva el siguiente index.html que deb\u00e9is crear dentro de la carpeta /var/www/webserver1/html:</p> <p></p> <p>Deb\u00e9is a\u00f1adir una cabecera que se llame Serv_Web1_vuestronombre. </p>"},{"location":"practica4/#nginx-servidor-web-2","title":"Nginx servidor web 2","text":"<p>En este servidor web debemos realizar una configuraci\u00f3n id\u00e9ntica al servidor web 1 pero cambiando webserver1 por webserver2 (tambi\u00e9n en el index.html), as\u00ed como el nombre de la cabecera a\u00f1adida, que ser\u00e1 Serv_Web2_vuestronombre. </p>"},{"location":"practica4/#nginx-proxy-inverso","title":"Nginx proxy inverso","text":"<p>Ya disponemos de los dos servidores web entre los que se van a repartir las peticiones que realice el cliente desde el navegador.</p> <p>Vamos, por tanto, a configurar el proxy inverso para que realice este reparto de peticiones:</p> <p>En sites-available deb\u00e9is crear el archivo de configuraci\u00f3n con el nombre balanceo. </p>"},{"location":"practica5/","title":"Pr\u00e1ctica 2.5 - Proxy inverso y balanceo de carga con SSL en NGINX","text":""},{"location":"practica5/#creacion-del-certificado","title":"Creaci\u00f3n del certificado","text":"<p>En este caso no habr\u00e1 peligro puesto que estamos 100% seguros que ese certificado lo hemos emitido nosotros para esta pr\u00e1ctica, no hay dudas.</p> <p>Veamos pues el proceso para generar los certificados y las claves asociadas a ellos (privada/p\u00fablica). En primer lugar debemos crear el siguiente directorio <code>/etc/nginx/ssl</code>:</p> <p>Vamos a crear el certificado y las claves de forma simult\u00e1nea con un \u00fanico comando:  </p> <p>Os solicitar\u00e1 que introduzc\u00e1is una serie de par\u00e1metros, como v\u00e9is en el recuadro rojo de abajo de la imagen. Deb\u00e9is introducir los mismos par\u00e1metros que en la imagen excepto en el \u201cOrganizational Unit Name\u201d que v\u00e9is recuadrado en amarillo. Ah\u00ed deber\u00e9is poner <code>2DAW \u2013 DEAW - Vuestronombre</code>.</p>"},{"location":"practica5/#configuracion-ssl-en-el-proxy-inverso","title":"Configuraci\u00f3n SSL en el proxy inverso","text":"<p>De la pr\u00e1ctica anterior, dentro del directorio <code>/etc/nginx/sites-available</code> ya deb\u00e9is tener el archivo de configuraci\u00f3n llamado balanceo. Es precisamente aqu\u00ed donde realizaremos la configuraci\u00f3n para que el acceso al sitio web se realice mediante SSL (HTTPS).</p> <p>Dentro del bloque server {\u2026} deb\u00e9is cambiar el puerto de escucha (listen 80) por lo que v\u00e9is en la imagen de abajo, a\u00f1adiendo las siguientes l\u00edneas de configuraci\u00f3n tambi\u00e9n, de tal forma que quede:</p> <pre><code>server {\n    listen 443 ssl;\n    ssl_certificate /etc/nginx/ssl/nginx.crt;\n    ssl_certificate_key /etc/nginx/ssl/nginx.key;\n    ssl_protocols TLSv1.2 TLSv1.3;\n    ssl_ciphers HIGH:!aNULL:!MD5;\n    server_name balanceo;\n    access_log /var/log/nginx/https_access.log;\n}\n</code></pre> <p></p> <p>Recordad que tras modificar cualquier configuraci\u00f3n de un servicio, hay que reiniciar el servicio, en este caso Nginx.</p> <pre><code>sudo systemctl restart nginx\n</code></pre>"},{"location":"practica5/#comprobaciones","title":"Comprobaciones","text":"<p>Si acced\u00e9is ahora a https://balanceo os deber\u00eda saltar un aviso de seguridad debido a que nuestro certificado es autofirmado, como coment\u00e1bamos anteriormente.</p> <p></p>"},{"location":"practica6/","title":"Despliegue de aplicaciones web Pr\u00e1ctica 3.1: Instalaci\u00f3n de Tomcat y Maven para despliegue de aplicaci\u00f3n Java","text":"<p>Esta pr\u00e1ctica es muy sencilla y va a consistir en realizar la instalaci\u00f3n del servidor de aplicaciones Tomcat 9, en una m\u00e1quina virtual corriendo Debian 11 Bullseye.</p>"},{"location":"practica6/#instalacion-tomcat-manual","title":"Instalaci\u00f3n Tomcat manual","text":"<p>Desde la p\u00e1gina odicial nos descargamos el archivo tar.gz</p> <p>Creamos el directorio <code>/otp/tomcat</code></p> <p>Extraemos el paquete descargado </p> <pre><code>sudo tar -xzvf apache-tomcat-*.tar.gz\n</code></pre> <p></p> <p>Movemos el contenido al directorio creado anteriormente <code>/opt/tomcat</code> </p> <p>A\u00f1adimos al grupo tomcat <code>sudo groupadd tomcat</code> </p> <p>Ahora, agregamos el usuario tomcat <code>sudo useradd -g tomcat -d /opt/tomcat -s /usr/sbin/nologin tomcat</code> </p> <p>Damos al usuario y grupo permisos recursivos sobre /opt/tomcat ejecutando el comando <code>sudo chown -R tomcat:tomcat /opt/tomcat/</code> </p> <p>Obtenemos la ruta del paquete Java que instalamos en los primero pasos del tutorial <code>sudo update-java-alternatives -l</code></p> <p>Creamos el archivo <code>sudo nano /etc/systemd/system/tomcat.service</code> y escribimos lo siguiente, sustituyendo la variable <code>JAVA_HOME</code> por nustra ruta</p> <pre><code>[Unit]\nDescription=Apache Tomcat\nWants=network.target\nAfter=network.target\n\n[Service]\nType=forking\n\nEnvironment=JAVA_HOME=/usr/lib/jvm/java-1.11.0-openjdk-amd64/\n\nEnvironment=CATALINA_PID=/opt/tomcat/temp/tomcat.pid\nEnvironment=CATALINA_HOME=/opt/tomcat\n\nEnvironment='CATALINA_OPTS=-Xms512M -Xmx1G -Djava.net.preferIPv4Stack=true'\nEnvironment='JAVA_OPTS=-Djava.awt.headless=true'\n\nExecStart=/opt/tomcat/bin/startup.sh\nExecStop=/opt/tomcat/bin/shutdown.sh\nSuccessExitStatus=143\n\nUser=tomcat\nGroup=tomcat\nUMask=0007\nRestartSec=10\nRestart=always\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p></p> <p>Damos permisos al script <code>chmod +x /opt/tomcat/bin/*.sh</code></p> <p>Arrancamos el servicio de Tomcat usando systemctl <code>sudo systemctl start tomcat.service</code> y comprobamos que esta corriendo <code>sudo systemctl status tomcat.service</code> </p> <p>Habilitamos el servicio <code>sudo systemctl enable tomcat</code> </p> <p>Ahora, a\u00f1adimos un usaruio de tomcat en el archivo de configuracion <code>/opt/tomcat/conf/</code>. <code>sudo nano /etc/tomcat9/tomcat-users.xml</code></p> <pre><code>&lt;role rolename=\"admin\"/&gt;\n&lt;role rolename=\"admin-gui\"/&gt;\n&lt;role rolename=\"manager\"/&gt;\n&lt;role rolename=\"manager-gui\"/&gt;\n\n&lt;user username=\"linuxhint\" password=\"YourPasswordHere\" roles=\"admin,admin-gui,manager,manager-gui\"/&gt;\n</code></pre> <p></p> <p>Ahora podemos acceder desde <code>`http://localhost:8080</code> </p>"},{"location":"practica6/#despliegue-con-maven","title":"Despliegue con Maven","text":"<p>Para instalar Maven en nuestro Debian tenemos, de nuevo, dos opciones: 1. Instalaci\u00f3n mediante gestor de paquetes APT 2. Instalaci\u00f3n manual</p> <p>La primera, recomendada, es mucho m\u00e1s sencilla y automatizada (establece todos los paths y variables de entorno), aunque con la segunda se podr\u00eda conseguir un paquete m\u00e1s actualizado.</p> <p>Si decidimos seguir el primer m\u00e9todo, el m\u00e1s sencillo, vemos que es tan simple como actualizar los repositorios:</p> <pre><code>sudo apt update\n</code></pre> <p>E instalar Maven:</p> <pre><code>sudo apt install maven\n</code></pre> <p>Para comprobar que todo ha ido correctamente, podemos ver la versi\u00f3n instalada de Maven:</p> <pre><code>mvn --version\n</code></pre> <p></p>"},{"location":"practica6/#configuracion-de-maven","title":"Configuraci\u00f3n de Maven","text":"<p>Para poder realizar despliegues en nuestro Tomcat previamente instalado, necesitamos realizar la configuraci\u00f3n adecuada para Maven. Ya sabemos que esto en Linux significa editar los archivos de configuraci\u00f3n adecuados. Vamos a ello.</p> <p>En primer lugar necesitamos asegurarnos de que en el apartado anterior de la pr\u00e1ctica hemos a\u00f1adido todos los usuarios necesarios, as\u00ed como sus respectivos roles. Debemos a\u00f1adir el rol de manager-script para permitir que Maven se autentique contra Tomcat y pueda realizar el despliegue.</p> <p>Los roles utilizados por Tomcat vienen detallados en su documentaci\u00f3n, que merece ser consultada.</p> <p>En dicha documentaci\u00f3n se nos indica que, por temas de seguridad, es recomendable no otorgar los roles de <code>manager-script</code> o <code>manager-jmx</code> al mismo usuario que tenga el rol de <code>manager-gui</code>.</p> <p>As\u00ed las cosas, modificamos el archivo <code>/etc/tomcat9/tomcat-users.xml</code> (o el <code>opt/tomcat/conf/tomcat-users.xml</code>si lo instalamos desde la pagina web sehun nos indica la guia de instalacion) acorde a nuestras necesidades (los nombres de usuario y contrase\u00f1a deber\u00e1n ser los que elij\u00e1is para vosotros):</p> <pre><code>&lt;role rolename=\"manager-gui\"/&gt;\n&lt;role rolename=\"manager-script\"/&gt;\n&lt;user username=\"gui-user\" password=\"gui-password\" roles=\"manager-gui\"/&gt;\n&lt;user username=\"script-user\" password=\"script-password\" roles=\"manager-script\"/&gt;\n</code></pre> <p></p> <p>Editar el archivo <code>/etc/maven/settings.xml</code> para indicarle a Maven, un identificador para el servidor sobre el que vamos a desplegar (no es m\u00e1s que un nombre, ponedle el nombre que consider\u00e9is), as\u00ed como las credenciales. Todo esto se har\u00e1 dentro del bloque <code>servers</code> del XML:</p> <pre><code>&lt;servers&gt;\n    &lt;server&gt;\n        &lt;id&gt;Tomcat.P.3.1&lt;/id&gt;\n        &lt;username&gt;script-user&lt;/username&gt;\n        &lt;password&gt;script-password&lt;/password&gt;\n    &lt;/server&gt;\n&lt;/servers&gt;\n</code></pre> <p></p> <p>Ahora debemos modificar el POM del proyecto para que haga referencia a que el despliegue se realice con el plugin de Maven para Tomcat.</p> <p>Otra opci\u00f3n ser\u00eda utilizar el plugin Cargo.</p> <p>Donde lo que a\u00f1adimos es el bloque:</p> <pre><code>&lt;build&gt;\n    &lt;finalName&gt;war-deploy&lt;/finalName&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;\n            &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;\n            &lt;version&gt;2.2&lt;/version&gt;\n            &lt;configuration&gt;\n                &lt;url&gt;http://localhost:8080/manager/text&lt;/url&gt;\n                &lt;server&gt;Tomcat.P.3.1&lt;/server&gt;\n                &lt;path&gt;/myapp&lt;/path&gt;\n            &lt;/configuration&gt;\n        &lt;/plugin&gt;\n    &lt;/plugins&gt;\n&lt;/build&gt;\n</code></pre> <p></p>"},{"location":"practica6/#despliegue","title":"Despliegue","text":"<p>Teniendo ya todo listo para realizar despliegues, ahora crearemos una aplicaci\u00f3n Java de prueba para ver si podemos desplegarla sobre la arquitectura que hemos montado. Para ello utilizamos el comando:</p> <pre><code>mvn archetype:generate -DgroupId=raul -DartifactId=war-deploy -DarchetypeArtifactId=maven-archetype-webapp -DinteractiveMode=false\n</code></pre> <p></p> <p>Pod\u00e9is sustituir los valores de <code>groupId</code> y <code>artifactId</code> (este ser\u00e1 el nombre de la aplicaci\u00f3n) por lo que quer\u00e1is.</p> <p>Tras generar esta aplicaci\u00f3n, los comandos finales que se utilizan en Maven para desplegar, volver a desplegar o desplegar una aplicaci\u00f3n, son:</p> <pre><code>mvn tomcat7:deploy\nmvn tomcat7:redeploy\nmvn tomcat7:undeploy\n</code></pre> <p></p> <p>Y, accediendo a trav\u00e9s de la GUI, debemos ver que la aplicaci\u00f3n est\u00e1 desplegada y que podemos acceder a ella perfectamente.</p>"},{"location":"practica7/","title":"Pr\u00e1ctica 3.2: Despliegue de aplicaciones con Node Express","text":""},{"location":"practica7/#instalacion-de-nodejs","title":"Instalaci\u00f3n de Node.js","text":"<p>Para utilizar Express.js, primero debemos instalar NodeJS . Para ello, tenemos varias formas, pero yo instalar\u00e9 la \u00faltima versi\u00f3n estable.</p> <p>Para completar esto, abra una terminal y primero actualice el sistema operativo. <code>sudo apt update</code> y <code>sudo apt upgrade</code>.</p> <p>Agregmos el 16.x repositorio de ramas de NodeJS.</p> <pre><code>curl -sL https://deb.nodesource.com/setup_16.x | sudo -E bash -\n</code></pre> <p> Ejecutamos el comando <code>sudo apt install nodejs</code></p>"},{"location":"practica7/#instalacion-de-expressjs","title":"Instalaci\u00f3n de ExpressJS","text":"<p>Ahora tenemos que instalar Express.js y para hacerlo globalmente tienes que ejecutar <code>sudo npm install -g express</code>. </p> <p>Luego creamos la carpeta del proyecto: <code>mkdir project</code> Accedemos a la carpeta <code>cd project</code> Luego inicializamos el proyecto <code>npm init -y</code>  Instalamos Express.js para este protecto localmente <code>npm install express</code>  Ahora crea un archivo de muestra <code>sudo nano app.js</code> y a\u00f1adimos lo siguiente: </p> <pre><code>const express = require('express')\nconst app = express()\nconst port = 3000\n\napp.get('/', (req, res) =&gt; {\n    res.send('Hello. Welcome to this blog')\n})\n\napp.listen(port, () =&gt; {\n    console.log(`Example app listening at http://localhost:${port}`)\n})\n</code></pre> <p></p> <p>Ahora ejecutmos el proyecto con <code>node app.js</code> </p> <p>Ahora abrimos el navegador con la url <code>http://localhost:3000</code> </p>"},{"location":"practica7/#despliegue-de-una-nueva-aplicacion","title":"Despliegue de una nueva aplicaci\u00f3n","text":"<p>Vamos ahora a realizar el despliegue de una aplicaci\u00f3n de terceros para ver c\u00f3mo es el proceso.</p> <p>Se trata de un \"prototipo\" de una aplicaci\u00f3n de predicci\u00f3n meteorol\u00f3gica que pod\u00e9is encontrar en este repositorio de Github.</p> <p>Tal y como indican las instrucciones del propio repositorio, los pasos a seguir son, en primer lugar, clonar el repositorio a nuesta m\u00e1quina:</p> <pre><code>git clone https://github.com/MehedilslamRipon/Shopping-Cart-Application\n</code></pre> <p>Nos movemos al nuevo directorio <code>cd Shopping-Cart-Application/</code> Instalamos las librer\u00edas necesarias <code>npm install</code> </p> <p>Por \u00faltimo, iniciamos la aplicaci\u00f3n <code>npm run start</code> Y no dar\u00e1 seguramente el siguiente error:  Instalamo nodemon <code>npm install nodemon --save-dev</code> y ya se soluciona el error. </p> <p>Ya podemos iniciar sin problema la p\u00e1gina en el navegador </p>"},{"location":"practica8/","title":"Pr\u00e1ctica 3.4: Despliegue de una aplicaci\u00f3n React en Netlify (PaaS)","text":"<p>Nos logeamos por SSH en nuestro Debian, desde el PC anfitri\u00f3n. Nos creamos un directorio para albergar la aplicaci\u00f3n con el nombre que queramos <code>mkdir mi-aplicacion-netlify</code>.  </p> <p>En este directorio, creamos los 3 archivos que conformar\u00e1 nuestra sencilla aplicaci\u00f3n de ejemplo:  </p> <p>Ahora, tal y como hacemos siempre a la hora de crear nuestra aplicaci\u00f3n Node.js, con el fin de crear el archivo package.json, utilizaremos en el terminal el comando: </p> <p>Ahora desde el navegador de la m\u00e1quina anfitriona podemos acceder a <code>http://IP-maq-virtual:8080</code>. </p>"},{"location":"practica8/#aplicacion-para-netlify","title":"Aplicaci\u00f3n para Netlify","text":"<p>Puesto que el inter\u00e9s en este m\u00f3dulo radica en el proceso de despliegue, suponiendo que la parte de desarrollo ya es abordada en otros m\u00f3dulos, vamos a utilizar una aplicaci\u00f3n de ejemplo que nos ahorre tiempo para centrarnos en el despliegue.</p> <p>Nos clonaremos este repositorio:</p> <pre><code>git clone https://github.com/StackAbuse/color-shades-generator\n</code></pre> <p></p>"},{"location":"practica8/#prceso-de-despliegue-en-netlify-mediante-cli","title":"Prceso de despliegue en Netlify mediante CLI","text":"<p>Una vez registrados, debemos instalar el CLI de Netlify para ejecutar sus comandos desde el terminal:<code>sudo npm install netlify-cli -g</code></p> <p>Nos logeamos <code>nerlify login</code> </p> <p>Nos muestra en el navegador, generamos el tokende acceso </p> <p>Bueno, tenemos el c\u00f3digo de nuestra aplicaci\u00f3n, tenemos nuestra cuenta en Netlify y tenemos el CLI necesario para ejecutar comandos desde el terminal en esa cuenta... \u00bfPodemos proceder al despliegue sin mayores complicaciones?</p> <p>La respuesta es NO, como buenos desarrolladores y en base a experiencias anteriores, ya sab\u00e9is que hay que hacer un build de la aplicaci\u00f3n para, posteriormente, desplegarla. Vamos a ello.</p> <p>En primer lugar, como sabemos, debemos instalar todas las dependencias que vienen indicadas en el archivo <code>package.json</code>: <code>npm install</code></p> <p>Y cuando ya las tengamos instaladas podemos proceder a realizar el build:<code>npm run build</code></p> <p></p> <p>Esto nos crear\u00e1 una nueva carpeta llamada build que contendr\u00e1 la aplicaci\u00f3n que debemos desplegar. Y ya podemos hacer un pre-deploy de la aplicaci\u00f3n de la que hemos hecho build antes: </p> <p>Nos har\u00e1 algunas preguntas para el desplieuge: Indicamos que queremos crear y configurar un nuevo site El Team lo dejamos por defecto Le indicamos el nombre que queremos emplear para la web (nombre-practica3-4) y el directorio a utilizar para el deploy (directorio ./build). Y si nos indica que todo ha ido bien e incluso podemos ver el \"borrador\" (Website Draft URL) de la web que nos aporta, podemos pasarla a producci\u00f3n finalmente tal y como nos indica la misma salida del comando: </p> <p>En primer lugar, vamos a eliminar el site que hemos desplegado antes en Netlify para evitarnos cualquier problema y/o conflicto:  Creamos una carpeta nueva y descomprimimos dentro el zip: </p> <p>Ahora debemos crear un repositorio completamente vac\u00edo en Github que se llame practicaTresCuatro: </p> <p>Y tras ello, volviendo al terminal a la carpeta donde est\u00e1bamos, la iniciamos como repositorio, a\u00f1adimos todo el contenido de la misma para el commit, hacemos el commit con el mensaje correspondiente y creamos la rama main: </p> <p>Y ahora s\u00f3lo queda referenciar nuestra carpeta al repositorio reci\u00e9n creado en Github y hacer un push para subir todo el contenido del commit a \u00e9l:</p> <p>Ahora que ya tenemos subido el c\u00f3digo a GitHub, de alguna manera debemos enganchar o enlazar nuestra cuenta de Github con la de Netlify para que \u00e9ste \u00faltimo pueda traerse el c\u00f3digo de all\u00ed, hacer el build y desplegarlo. As\u00ed pues, entramos en nuestro dashboard de Netlify y le damos a importar proyecto existente de git Le indicamos que concretamente de Github: Y nos saltar\u00e1 una ventana pidiendo que autoricemos a Netlify a acceder a nuestros repositorios de Github: </p> <p>Y desplegamos la aplicaci\u00f3n: </p> <p> Dentro de la carpeta public encontramos el archivo robots.txt, cuyo cometido es indicar a los rastreadores de los buscadores a qu\u00e9 URLs del sitio pueden acceder. A este archivo se puede acceder a trav\u00e9s de la URL del site:  Haz un nuevo commit y push (del caso anterior, recuerda el commando git previo para a\u00f1adir los archivos a hacer commit)</p> <p>Comprueba en el dashboard de Netlify que se ha producido un nuevo deploy de la aplicaci\u00f3n hace escasos segundos  </p> <p>Accede a <code>https://url_de_la_aplicacion/robots.txt</code> y comprueba que, efectivamente, se ve reflejado el cambio </p>"},{"location":"practica9/","title":"Pr\u00e1ctica 3.5 - Despliegue de una aplicaci\u00f3n Flask","text":""},{"location":"practica9/#procedimiento","title":"Procedimiento","text":"<p>Instalamos el gestor de pauetes de Python <code>pip</code>:</p> <pre><code>sudo apt update\n\nsudo apt install python3-pip\n\n</code></pre> <p></p> <p>Instalamos <code>pipenv</code></p> <pre><code>sudo apt install pipenv\n</code></pre> <p></p> <p>Despu\u00e9s de haberlo instalado comprobamos que est\u00e1 instalado correctamente con <code>pipenv --version</code> </p> <p>Seguido de esto creamos un directorio en el que almacenaremos nuestro proyecto <code>sudo mkdir /var/www/nombre_mi_aplicacion</code> </p> <p>Si hemos creado el directrio con sudo, tenemos que cambiarle los permisos para que el due\u00f1o sea nuestro usuario (ud24) y pertenezca al grupo <code>www-data</code></p> <pre><code>sudo chown -R $USER:www-data /var/www/mi_aplicacion\n\nchmod -R 775 /var/www/mi_aplicacion   \n</code></pre> <p></p> <p>Ahora, tenemos que crear un archivo oculto <code>.env</code> dentro de nuestra aplicaci\u00f3n </p> <p>Hay que modificar el arvhivo y a\u00f1adir las variables, indicando cual es el arvhivo <code>.py</code> de la aplicaci\u00f3n. </p> <p>Iniciamos el entorno virtual <code>pipenv shell</code> </p> <p>Instalamos las dependencias de nuestro proyecto <code>pipenv install flask gunicorn</code> </p> <p>Vamos a crear la aplicaci\u00f3n Flask m\u00e1s simple posible <code>touch application.py wsgi.py</code> </p> <p>A\u00f1adimos la siguiente configuraci\u00f3n a los archivos: application.py:</p> <pre><code>from flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    '''Index page route'''\n\n    return '&lt;h1&gt;Aplicacion desplegada&lt;/h1&gt;'\n</code></pre> <p>wsgi.py</p> <pre><code>from application import app\n\nif __name__ == '__main__':\n    app.run(debug=False)\n</code></pre> <p> </p> <p>Lanzamos la aplicaci\u00f3n con el comando <code>flask run --host '0.0.0.0'</code> </p> <p>Podemos acceder desde nuestra m\u00e1quina anfitriona accediento a la Ip de la m\u00e1quina virtual y el puerto <code>5000</code> </p> <p>Si ha funcionado lo anterior, vamos a comprobar que funciona correctamente usando Gunicorn. <code>gunicorn --workers 4 --bind 0.0.0.0:5000 wsgi:app</code> </p> <p>Todav\u00eda dentro de nuestro entorno virtual, debemos tomar nota de cual es el path o ruta desde la que se ejecuta gunicorn para poder configurar m\u00e1s adelante un servicio del sistema. Podemos averigurarlo as\u00ed: </p> <p>Iniciamos Nginx y comprobamos que se ha activado</p> <pre><code>sudo systemctl start nginx\n\nsudo systemctl status nginx\n</code></pre> <p></p> <p>Ahora, fuera de nuestro entrono virtual, tnenmos que crear un archivo para que systemd corra Gunicorn como un servicio <code>sudo nano /etc/systemd/system/flask_app.service</code> </p> <p>Habiltamos el servicio y se inicia</p> <pre><code>systemctl enable nombre_mi_servicio\n\nsystemctl start nombre_mi_servicio\n</code></pre> <p></p> <p>Creamos un archivo con el nombre de nuestra aplicaci\u00f3n y dentro estableceremos la configuraci\u00f3n para ese sitio web. El archivo, como record\u00e1is, debe estar en /etc/nginx/sites-available/nombre_aplicacion y tras ello lo editamos para que quede:</p>"}]}